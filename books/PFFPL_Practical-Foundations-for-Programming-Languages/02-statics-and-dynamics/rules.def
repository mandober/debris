# 2. Statics and Dynamics :: Statics :: RULES

This syntax chart summarizes the abstract and concrete syntax of lang E:

```hs
Typ   œÑ := num                num                   numbers
         | str                str                   strings

Exp   e := x                  x                     variable
         | num[n]             n                     numeral
         | str[s]             "s"                   literal
         | plus(e1; e2)       e1 + e2               addition
         | times(e1; e2)      e1 * e2               multiplication
         | cat(e1; e2)        e1 ^ e2               concatenation
         | len(e)             |e|                   length
         | let(e1; x.e2)      let x = e1 in e2      definition
```

This chart defines two sorts:
- `Typ`, meta var `œÑ` ranges over types
- `Exp`, meta var `e` ranges over expressions

The chart defines a set of operators and their arities. 
For example, it specifies that the operator let has arity `(Exp, Exp.Exp)Exp`, which specifies that it has two args of sort `Exp`, and binds a variable of sort `Exp` in the second arg.


Legend
- `xÃÖ` is a finite set of vars
- `Œì` is a typing context consisting of hypotheses of the form `x : œÑ`
- vars use the letters `x` and `y` to stand for them
- `x ‚àâ dom(Œì)` says there's no assumption in `Œì` of the form `x : œÑ` for any type `œÑ`, in which case we say that the var `x` is fresh for `Œì`


The rules defining the statics of E:

```hs
-------------------------- (4.1a)
Œì, x‚Åü:‚ÅüœÑ |- x‚Åü:‚ÅüœÑ

-------------------------- (4.1b)
Œì |- ùë†ùë°ùëü[s]‚Åü:‚Åüùë†ùë°ùëü

-------------------------- (4.1c)
Œì |- ùëõùë¢ùëö[n]‚Åü:‚Åüùëõùë¢ùëö


Œì |- e1‚Åü:‚Åüùëõùë¢ùëö     Œì |- e2‚Åü:‚Åüùëõùë¢ùëö
--------------------------------- (4.1d)
Œì |- ùëùùëôùë¢ùë†(e1; e2)‚Åü:‚Åüùëõùë¢ùëö

Œì |- e1‚Åü:‚Åüùëõùë¢ùëö     Œì |- e2‚Åü:‚Åüùëõùë¢ùëö
--------------------------------- (4.1e)
Œì |- ùë°ùëñùëöùëíùë†(e1; e2)‚Åü:‚Åüùëõùë¢ùëö

Œì |- e1‚Åü:ùë†ùë°ùëü     Œì |- e2‚Åü:ùë†ùë°ùëü
--------------------------------- (4.1f)
Œì |- ùëêùëéùë°(e1; e2)‚Åü:ùë†ùë°ùëü

Œì |- e‚Åü:ùë†ùë°ùëü
--------------------------------- (4.1g)
Œì |- ùëôùëíùëõ(e)‚Åü:‚Åüùëõùë¢ùëö


Œì |- e‚ÇÅ‚Åü:‚ÅüœÑ‚ÇÅ    Œì,‚Åüx‚Åü:‚ÅüœÑ‚ÇÅ |- e‚ÇÇ‚Åü:‚ÅüœÑ‚ÇÇ
--------------------------------- (4.1h)
Œì |- let(e‚ÇÅ; x.e‚ÇÇ)‚Åü:‚ÅüœÑ‚ÇÇ
```

>(Lemma 4.1) **Unicity of Typing**: For every typing context `Œì` and exp `e`, there exists at most one `œÑ` such that `Œì |- e : œÑ`.

>(Lemma 4.3) **Weakening**. If `Œì |- e':‚ÅüœÑ'` then `Œì,‚Åüx‚Åü:‚ÅüœÑ |- e':‚ÅüœÑ'` for any `x ‚àâ dom(Œì)` and any type `œÑ` that `x` has.

>(Lemma 4.4) **Substitution**. If `Œì,x:œÑ |- e':œÑ'` and `Œì |- e:œÑ`, then `Œì |- [e/x]e':œÑ'`

>(Lemma 4.5) **Decomposition**. If `Œì |- [e/x]e' : œÑ'`, then for every type `œÑ` such that `Œì |- e : œÑ`, we have `Œì, x : œÑ |- e' : œÑ'`.


The *iteration* of transition judgment `s ‚üº* s'` is inductively defined:

```hs
-------------------- (5.1a)
s ‚üº* s'

s ‚üº s'   s' ‚üº s''
-------------------- (5.1b)
s ‚üº s''
```

The *n-times iterated* transition judgment `s ‚üº‚Åø s'`, where n ‚â• 0, is inductively defined by the following rules:

```
---------------------- (5.2a)
s ‚üº‚Å∞ s

s ‚üº s'   s' ‚üº‚Åø s''
---------------------- (5.2b)
s ‚üº‚Åø·ê©¬π s''
```



## 5.2 Structural Dynamics

A *structural dynamics* for the language E is given by a transition system whose states are closed expressions. All states are initial. The final states are the *(closed) values*, which represent the completed computations. The judgment `e val`, which states that `e` is a value, is inductively defined by the following rules:

```hs
----------- (5.3a)
num[n] val

----------- (5.3b)
str[s] val
```

The transition judgment `e ‚üº e'` between states is inductively defined by the following rules:

```hs
          n‚ÇÅ + n‚ÇÇ = n
--------------------------------- (5.4a) instruction trans
plus(num[n‚ÇÅ]; num[n‚ÇÇ]) ‚üº num[n]

          e‚ÇÅ ‚üº e‚ÇÅ'
--------------------------------- (5.4b) search trans
plus(e‚ÇÅ; e‚ÇÇ) ‚üº plus(e‚ÇÅ'; e‚ÇÇ)

          e‚ÇÇ ‚üº e‚ÇÇ'
--------------------------------- (5.4c) search trans
plus(v ; e‚ÇÇ) ‚üº plus(v ; e‚ÇÇ')
--   ^               ^
--      v = e‚ÇÅ val



        s‚ÇÅ ^ s‚ÇÇ = s str
---------------------------------- (5.4d)  instruction trans
cat(str[s‚ÇÅ]; str[s‚ÇÇ]) ‚üº str[s]

         e‚ÇÅ ‚üº e‚ÇÅ'
---------------------------------- (5.4e) search trans
cat(e‚ÇÅ; e‚ÇÇ) ‚üº cat(e‚ÇÅ'; e‚ÇÇ)

         e‚ÇÇ ‚üº e‚ÇÇ'
---------------------------------- (5.4f) search trans
cat(v ; e‚ÇÇ) ‚üº cat(v; e‚ÇÇ')
--  ^              ^
--     v = e‚ÇÅ val


‚é°            e‚ÇÅ ‚üº e‚ÇÅ'                                 ‚é§
‚é¢ -------------------------------- (5.4g) search trans ‚é•
‚é£ let(e‚ÇÅ; x.e‚ÇÇ) ‚üº let(e‚ÇÅ'; x.e‚ÇÇ)                      ‚é¶


‚é° e‚ÇÅ val ‚é§
----------------------------- (5.4h) instruction trans
let(e‚ÇÅ; x.e‚ÇÇ) ‚üº [x:=e‚ÇÅ]e‚ÇÇ
```

The entire rule (5.4g) and the premise on rule (5.4h) are bracketed to indicate that this rule and premise are *included in by-value* interpretation and *omitted in by-name* interpretation.
