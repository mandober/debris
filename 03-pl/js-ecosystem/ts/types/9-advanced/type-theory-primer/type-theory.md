# Type system :: Type theory

TypeScript introduces a type system over the untyped and dynamic JavaScript in order to help programmers make less mistakes.

A type system is the cheapest and very effect safety net against many programming errors. Alternatively, we'd have to proof the properties we'd like our progreams to guarantee. Or we'd have to learn a lot more complex mathematical notations to establish denotational semantics. Or we'd have to use specialized languages that can express, e.g. pre and post conditions. Type systems are a great compromise between safety and convenience and efficiancy. The best thing about them is that we get all they offer practically for free since everything is done when it's cheap - at compile time. Making assertions in programs - liek it's often done in JS since there is no other solution available - can only be done at runtime when such checks not only affect perfomance but are repeated redundantly too many times, when only once would suffice.

Of course, how much we benefit, safety-wise, from a type system depends on its features. In this day and age, the absolute minimum, the bottom line should be Hilney-Milner (HM) type system created half a century ago and imensly improved since then. Still most of today's mainstream languages use archaic, C-like type system that helps as little as possible (forget about generics and generic safety). Of course, C's type system was great for its time, soem 70 years ago, but there are far more superior solutions available today resulting from the 70+ years of developments in computer science and particularly, theory of programming languages. It is especially depressive when a new languages comes out that uses a type system that was deemed too weak and obsolete already in 1970's.

The strenght of HM type system is total type safety with minimal effost from the programmer regarding the manual placement of type annotation. The sytem is capable to infer the types of almost every expression, with no user intervention still only a few of modern PLs (Rust, Swift, Scala) take advantage of it.

Haskell is usually taken as the role model language, at least type-wise, due to its concise sytax for denoting types and fucntions signatures especially. Of course, Haskell is based on HM but it has went so far beyond it. However, as of 2023 it hasn't went too far (still no proper dependent types), having a type system in a perfect middle position between useful and somewhat less complicated (PLs with dependent types loose the ability not to require programmer's attention to type annotation). 

Whether a PL allows us to elide type annotations does not mean we should. Learning about types, their machanics and behaviours is a must regardless. Perhaps only experts can afford to elide annotating types and that only in case when they're trying to rapidly prototype something. Knowing everything - which value and which expression has what type is absolutely required to understand a program. Knowing the type (type-level thing) makes writing the implementation (value-level thing) much easier (aka type-driven development).
